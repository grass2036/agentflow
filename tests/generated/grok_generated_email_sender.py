#!/usr/bin/env python3
"""
Python Email Sender - Generated by X.AI Grok (Simulated Response)
Model: grok-3-mini
Agent: Backend Developer
Generated for: Comprehensive email sending functionality
"""

import smtplib
import ssl
import os
import re
import logging
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from typing import List, Dict, Optional, Union, Tuple
from pathlib import Path
import time

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class EmailSender:
    """
    Comprehensive email sending class with support for multiple providers,
    attachments, HTML/text emails, and robust error handling.
    """
    
    # SMTP configurations for popular providers
    SMTP_CONFIGS = {
        'gmail': {
            'server': 'smtp.gmail.com',
            'port': 587,
            'use_tls': True,
            'requires_app_password': True
        },
        'outlook': {
            'server': 'smtp.live.com',
            'port': 587,
            'use_tls': True,
            'requires_app_password': False
        },
        'yahoo': {
            'server': 'smtp.mail.yahoo.com',
            'port': 587,
            'use_tls': True,
            'requires_app_password': True
        },
        'custom': {
            'server': None,
            'port': 587,
            'use_tls': True,
            'requires_app_password': False
        }
    }
    
    def __init__(self, 
                 email: str, 
                 password: str, 
                 provider: str = 'gmail',
                 custom_smtp_server: Optional[str] = None,
                 custom_port: Optional[int] = None):
        """
        Initialize EmailSender
        
        Args:
            email: Sender email address
            password: Email password or app password
            provider: Email provider ('gmail', 'outlook', 'yahoo', 'custom')
            custom_smtp_server: Custom SMTP server (required if provider='custom')
            custom_port: Custom SMTP port (optional, defaults to 587)
        """
        self.email = email
        self.password = password
        self.provider = provider.lower()
        
        if self.provider not in self.SMTP_CONFIGS:
            raise ValueError(f"Unsupported provider. Choose from: {list(self.SMTP_CONFIGS.keys())}")
        
        self.config = self.SMTP_CONFIGS[self.provider].copy()
        
        if self.provider == 'custom':
            if not custom_smtp_server:
                raise ValueError("custom_smtp_server is required when provider='custom'")
            self.config['server'] = custom_smtp_server
            if custom_port:
                self.config['port'] = custom_port
        
        # Validate email format
        if not self._validate_email(email):
            raise ValueError(f"Invalid email format: {email}")
    
    @staticmethod
    def _validate_email(email: str) -> bool:
        """Validate email format using regex"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
    
    def _create_connection(self) -> smtplib.SMTP:
        """Create and configure SMTP connection"""
        try:
            logger.info(f"Connecting to {self.config['server']}:{self.config['port']}")
            
            # Create SMTP connection
            smtp = smtplib.SMTP(self.config['server'], self.config['port'])
            smtp.ehlo()
            
            # Enable TLS if required
            if self.config['use_tls']:
                context = ssl.create_default_context()
                smtp.starttls(context=context)
                smtp.ehlo()
            
            # Login
            smtp.login(self.email, self.password)
            logger.info("SMTP connection established successfully")
            
            return smtp
            
        except smtplib.SMTPAuthenticationError as e:
            error_msg = f"Authentication failed. Check email/password. For Gmail, use app password. Error: {e}"
            logger.error(error_msg)
            raise Exception(error_msg)
        except smtplib.SMTPConnectError as e:
            error_msg = f"Failed to connect to SMTP server. Error: {e}"
            logger.error(error_msg)
            raise Exception(error_msg)
        except Exception as e:
            error_msg = f"Unexpected error creating SMTP connection: {e}"
            logger.error(error_msg)
            raise Exception(error_msg)
    
    def send_email(self,
                   to_emails: Union[str, List[str]],
                   subject: str,
                   body: str,
                   is_html: bool = False,
                   cc_emails: Optional[Union[str, List[str]]] = None,
                   bcc_emails: Optional[Union[str, List[str]]] = None,
                   attachments: Optional[List[str]] = None,
                   max_retries: int = 3,
                   retry_delay: int = 1) -> Tuple[bool, str]:
        """
        Send email with comprehensive options
        
        Args:
            to_emails: Recipient email(s)
            subject: Email subject
            body: Email body content
            is_html: Whether body is HTML format
            cc_emails: CC recipients
            bcc_emails: BCC recipients
            attachments: List of file paths to attach
            max_retries: Maximum retry attempts
            retry_delay: Delay between retries (seconds)
            
        Returns:
            Tuple of (success: bool, message: str)
        """
        
        # Normalize email lists
        to_list = [to_emails] if isinstance(to_emails, str) else to_emails
        cc_list = [cc_emails] if isinstance(cc_emails, str) else (cc_emails or [])
        bcc_list = [bcc_emails] if isinstance(bcc_emails, str) else (bcc_emails or [])
        
        # Validate all email addresses
        all_emails = to_list + cc_list + bcc_list
        for email in all_emails:
            if not self._validate_email(email):
                return False, f"Invalid email address: {email}"
        
        # Create message
        try:
            msg = self._create_message(
                to_list, subject, body, is_html, cc_list, bcc_list, attachments
            )
        except Exception as e:
            return False, f"Failed to create message: {e}"
        
        # Send with retry logic
        for attempt in range(max_retries):
            try:
                smtp = self._create_connection()
                
                # Send email
                all_recipients = to_list + cc_list + bcc_list
                smtp.send_message(msg, to_addrs=all_recipients)
                smtp.quit()
                
                success_msg = f"Email sent successfully to {len(all_recipients)} recipients"
                logger.info(success_msg)
                return True, success_msg
                
            except Exception as e:
                error_msg = f"Attempt {attempt + 1} failed: {e}"
                logger.warning(error_msg)
                
                if attempt < max_retries - 1:
                    logger.info(f"Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                else:
                    final_error = f"Failed to send email after {max_retries} attempts. Last error: {e}"
                    logger.error(final_error)
                    return False, final_error
        
        return False, "Unexpected error in retry loop"
    
    def _create_message(self,
                       to_list: List[str],
                       subject: str,
                       body: str,
                       is_html: bool,
                       cc_list: List[str],
                       bcc_list: List[str],
                       attachments: Optional[List[str]]) -> MIMEMultipart:
        """Create email message with attachments"""
        
        msg = MIMEMultipart()
        msg['From'] = self.email
        msg['To'] = ', '.join(to_list)
        msg['Subject'] = subject
        
        if cc_list:
            msg['Cc'] = ', '.join(cc_list)
        
        # Add body
        if is_html:
            msg.attach(MIMEText(body, 'html'))
        else:
            msg.attach(MIMEText(body, 'plain'))
        
        # Add attachments
        if attachments:
            for file_path in attachments:
                if not os.path.isfile(file_path):
                    raise FileNotFoundError(f"Attachment not found: {file_path}")
                
                with open(file_path, "rb") as attachment:
                    part = MIMEBase('application', 'octet-stream')
                    part.set_payload(attachment.read())
                
                encoders.encode_base64(part)
                filename = os.path.basename(file_path)
                part.add_header(
                    'Content-Disposition',
                    f'attachment; filename= {filename}'
                )
                msg.attach(part)
                logger.info(f"Added attachment: {filename}")
        
        return msg
    
    def send_html_email(self,
                       to_emails: Union[str, List[str]],
                       subject: str,
                       html_content: str,
                       **kwargs) -> Tuple[bool, str]:
        """Convenience method for sending HTML emails"""
        return self.send_email(to_emails, subject, html_content, is_html=True, **kwargs)
    
    def send_plain_email(self,
                        to_emails: Union[str, List[str]],
                        subject: str,
                        text_content: str,
                        **kwargs) -> Tuple[bool, str]:
        """Convenience method for sending plain text emails"""
        return self.send_email(to_emails, subject, text_content, is_html=False, **kwargs)


def create_email_sender(provider: str = 'gmail') -> EmailSender:
    """
    Factory function to create EmailSender with environment variables
    
    Expected environment variables:
    - EMAIL_ADDRESS: Your email address
    - EMAIL_PASSWORD: Your email password/app password
    - SMTP_SERVER: Custom SMTP server (for custom provider)
    - SMTP_PORT: Custom SMTP port (optional)
    """
    
    email_address = os.getenv('EMAIL_ADDRESS')
    email_password = os.getenv('EMAIL_PASSWORD')
    
    if not email_address or not email_password:
        raise ValueError("EMAIL_ADDRESS and EMAIL_PASSWORD environment variables are required")
    
    kwargs = {
        'email': email_address,
        'password': email_password,
        'provider': provider
    }
    
    if provider == 'custom':
        smtp_server = os.getenv('SMTP_SERVER')
        smtp_port = os.getenv('SMTP_PORT')
        
        if not smtp_server:
            raise ValueError("SMTP_SERVER environment variable is required for custom provider")
        
        kwargs['custom_smtp_server'] = smtp_server
        if smtp_port:
            kwargs['custom_port'] = int(smtp_port)
    
    return EmailSender(**kwargs)


# Example usage and demonstrations
def demo_basic_usage():
    """Demonstrate basic email sending"""
    print("📧 Basic Email Demo")
    print("-" * 30)
    
    # Note: In production, use environment variables
    sender = EmailSender(
        email="your-email@gmail.com",
        password="your-app-password",  # Use app password for Gmail
        provider="gmail"
    )
    
    # Send simple text email
    success, message = sender.send_plain_email(
        to_emails="recipient@example.com",
        subject="Test Email from Python",
        text_content="Hello! This is a test email sent from Python using the EmailSender class."
    )
    
    print(f"Result: {message}")

def demo_html_email():
    """Demonstrate HTML email with styling"""
    print("🎨 HTML Email Demo")
    print("-" * 30)
    
    html_content = """
    <html>
      <body>
        <h2 style="color: #2E8B57;">Welcome to Our Service!</h2>
        <p>Dear User,</p>
        <p>Thank you for joining us. Here are some key features:</p>
        <ul>
          <li><strong>Feature 1:</strong> Advanced analytics</li>
          <li><strong>Feature 2:</strong> Real-time notifications</li>
          <li><strong>Feature 3:</strong> Secure data storage</li>
        </ul>
        <p>Best regards,<br>The Team</p>
        <hr>
        <p style="font-size: 12px; color: #666;">
          This email was sent from our automated system.
        </p>
      </body>
    </html>
    """
    
    sender = create_email_sender('gmail')
    
    success, message = sender.send_html_email(
        to_emails=["user1@example.com", "user2@example.com"],
        subject="Welcome to Our Platform!",
        html_content=html_content,
        cc_emails="manager@example.com"
    )
    
    print(f"Result: {message}")

def demo_attachments():
    """Demonstrate email with attachments"""
    print("📎 Attachment Demo")
    print("-" * 30)
    
    # Create a sample file for demonstration
    sample_file = "sample_attachment.txt"
    with open(sample_file, 'w') as f:
        f.write("This is a sample attachment file.\nGenerated for email demo.")
    
    sender = create_email_sender('outlook')
    
    success, message = sender.send_email(
        to_emails="recipient@example.com",
        subject="Email with Attachment",
        body="Please find the attached file.",
        attachments=[sample_file]
    )
    
    print(f"Result: {message}")
    
    # Clean up
    os.remove(sample_file)

def demo_bulk_email():
    """Demonstrate sending to multiple recipients"""
    print("📮 Bulk Email Demo")
    print("-" * 30)
    
    recipients = [
        "user1@example.com",
        "user2@example.com",
        "user3@example.com"
    ]
    
    sender = create_email_sender('yahoo')
    
    for i, recipient in enumerate(recipients, 1):
        personalized_content = f"""
        Hello {recipient.split('@')[0]},
        
        This is email #{i} in our bulk sending demonstration.
        Each email can be personalized for the recipient.
        
        Best regards,
        Email Bot
        """
        
        success, message = sender.send_plain_email(
            to_emails=recipient,
            subject=f"Personalized Email #{i}",
            text_content=personalized_content
        )
        
        print(f"Email {i}: {message}")
        
        # Add delay to avoid rate limiting
        time.sleep(1)

if __name__ == "__main__":
    print("🚀 Python Email Sender - Generated by X.AI Grok")
    print("=" * 60)
    print()
    
    # Setup instructions
    print("📋 Setup Instructions:")
    print("1. Set environment variables:")
    print("   export EMAIL_ADDRESS='your-email@gmail.com'")
    print("   export EMAIL_PASSWORD='your-app-password'")
    print()
    print("2. For Gmail, enable 2FA and create an app password:")
    print("   https://support.google.com/accounts/answer/185833")
    print()
    print("3. Run the desired demo function")
    print()
    
    # Uncomment to run demos (after setting up environment variables)
    # demo_basic_usage()
    # demo_html_email()
    # demo_attachments()
    # demo_bulk_email()
    
    print("✅ Email sender class ready for use!")